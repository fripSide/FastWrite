基于 **Pi Agent (OpenClaw 核心引擎)** 的极简主义设计哲学，以及 Tony Bai 和 53AI 文章中的深度解析，我们可以总结出 Pi 不通过代码强制实现“Planning Mode”（规划模式）的深层原因，并以此探讨学术写作中的规划问题。

### 一、 Pi Agent 的实现：为什么不需要“Planning Mode”？

Pi 的核心设计哲学是 **"Opinionated and Minimal"（固执且极简）**。它认为现有的 Agent 框架（如 Claude Code, OpenHands）过度工程化了。

Pi 只有四个核心工具：`Read`（读文件）、`Write`（写文件）、`Edit`（修改文件）、`Bash`（执行命令）。基于这四个原子能力，它通过以下逻辑废除了内置的“规划模式”：

#### 1. “文件即状态” (Files are State) —— 替代内存中的 Plan

传统的 Agent 会在内存里维护一个复杂的 JSON 对象来记录“当前计划步骤”、“已完成步骤”。

- **Pi 的做法：** 状态应该存在于用户可见的文件中，而不是 Agent 的黑盒内存里。
    - 如果你需要计划，Agent 会创建一个 `PLAN.md` 或 `TODO.md` 文件。
    - Agent 每次行动前读取这个文件，执行完划掉一项，然后更新文件。
    - **优势：** 实现了完美的持久化（Agent 重启还在）、可读性（用户随时能改计划）、可控性（用户可以直接编辑 Markdown 文件来干预 Agent 的下一步）。

#### 2. “Prompt 即代码” (Prompts are Code) —— 替代硬编码逻辑

传统框架试图用 Python 代码写死“先思考，再规划，再执行”的流程（即 Chain of Thought 的硬编码版）。

- **Pi 的做法：** 相信前沿模型（Frontier Models）的智力。
    - 不需要教模型“你是一个工程师，你要先做计划”，只需要给它工具。
    - 通过自然语言交互：“嘿，先帮我列个计划写在 PLAN.md 里，然后按顺序执行。”
    - 模型本身的能力足以理解并执行这个指令，无需框架层面的 State Machine（状态机）介入。

#### 3. “Bash 即通用接口” —— 替代复杂的子任务分发

传统框架会有 Sub-agents（子智能体）的概念，主智能体派发任务给子智能体。

- **Pi 的做法：** 利用 `tmux` 和 `bash`。
    - 如果需要并行任务（比如一边跑服务器一边改代码），Agent 直接在终端里开一个 `tmux` 会话。
    - 这种方式利用了操作系统原生的多任务能力，而不是在 Python 层面重新造轮子。

**总结：** Pi 不需要 Planning Mode，因为 **Markdown 文件就是最好的规划载体，而 LLM 本身就是最好的规划执行者。** 这种“透明化”设计把控制权还给了用户。

---

### 二、 论文写作是否需要 Planning Mode？

基于 Pi 的哲学，答案是：**不需要“硬编码的 Planning Mode”，但绝对需要“作为文件的 Plan（大纲）”。**

在学术写作场景中，我们可以将 Pi 的理念迁移过来：

#### 1. 拒绝“黑盒规划”

你不需要一个复杂的 UI 弹窗让你填“目标、受众、风格”，然后 Agent 在后台生成一个你看不见的 Prompt 链条。这会让你失去对论文逻辑的掌控。

#### 2. 拥抱“大纲即状态” (Outline as State)

在论文写作软件中，**左侧的目录树（大纲）就是 Pi 里的 `PLAN.md`。**

- **显性化：** 每一章（Introduction, Method...）就是计划的一个节点。
- **状态标记：** 每一章的状态（🔴未开始、🔵撰写中、🟢已锁定）就是进度的可视化。
- **交互逻辑：** 用户点击大纲的某一节，就是告诉 Agent：“现在的 Context 是这一块，请执行这一块的 Plan。”

#### 3. 动态调整 (Malleable like Clay)

正如 Pi 允许用户随时修改 `TODO.md` 来改变 Agent 的行为，写作软件也应允许用户随时拖拽大纲、修改章节标题。

- Agent 不应该死板地执行“写完第一章写第二章”。
- 用户应该能随时打断：“先别写 Method 了，我发现 Related Work 漏了一篇论文，先去更新那个文件。”

### 三、 结合“分块写作”的最终交互建议

回到你最初的“分块写作”设计，结合 Pi 的哲学，交互应该这样优化：

1. **显性化的 Plan 文件：**  
    不要把大纲只当成导航条。界面上应该有一个区域（或文件视图），专门显示 **"Writing_Plan.md"**。Agent 的每一步思考和生成的草稿，都是围绕更新这个文件进行的。
    
2. **Context 的透明化：**  
    不要让系统自动决定读取哪些文献。像 Pi 只有 `read` 工具一样，让用户明确看到 Agent 当前“读”了哪些 PDF（Context Window 里有什么）。用户可以手动移除不相关的文献，防止幻觉。
    
3. **极简的工具集：**  
    写作 Agent 只需要三个工具：
    
    - `Search_References` (查)
    - `Read_Content` (读)
    - `Write_Section` (写)  
        不需要复杂的“反思模式”、“润色模式”等按钮，这些都可以通过用户直接修改 Prompt（或在大纲文件中写批注）来实现。

**结论：**  
最好的“Planning Mode”不是一个软件功能模块，而是一份**用户和 AI 都能读写、实时同步的文档（大纲）**。这就是 Pi 给我们的最大启示——**用数据结构（文件）代替控制流（代码）**。